Written Product for Final Project
	In this project my main goal was to see how well generative AI could write a modular reusable flask framework to form and create new apps with just a couple quick changes and clicks. The web application is formed from a set of interchangeable components that I refer to as modules. Creating a functional, expandable system while also tracking and evaluating how well AI assisted my coding process, and influenced my learning, critical thinking, as well as my software development skillset. From completing this project I have exceeded my previously set learning/experience goal, and this written product documents my evidence, progress, as well as my final outcome, in a way that connects it to the course objectives overall. My product which I will describe in more detail is essentially an instant app creation tool that cuts the gruntwork of coding the flask framework and other useful modules. 
	
    To demonstrate the credibility and completeness of the project in terms of the learning goals (I feel there is so much more that can be done outside of project scope) I have outlined the evidence produced through using the generative AI to assist in my development process. 
    
    Firstly, the application as-is has six modules, fully implemented and ready to use; As follows the modules are: dashboard, main, authorization, database, chat, and blog. I will detail now what each module entails for the overall product. Dashboard and main are kind of the base of the web application that is being built, where main is more of a landing page that describes the product and not so much as useful as dashboard, right now main is a project home page, about page as well as a contact page. Whereas dashboard is a comprehensive home page that structures the application based on the variant that is selected (as-is there are 3 variants: default, blog, and chat). Authorization as expected is used for implementing user login/signup/logout using key security concepts such as password hashing through bcrypt, it also adds sessions and user persistence as well. Database is a key module to the project as SQLite integration, user persistence, etc. are all implemented through this module. Blog is a usage module and implements a full CRUD blog with categories, archives, and a search ability. And lastly the chat module which implements room-based chat systems, with message handling and API endpoints. While these modules can be paired and used together some (not all, as dependency issues were worked out) work solely independent of one another.
    
    Next I want to talk about the themes and how it affects the user interface output. Within the products system there are four production-ready themes already incorporated and ready to use. Right now these themes are: light-professional (default), dark-modern, cyberpunk-neon, and space-animated, all of which offer a unique look and feel to the application that is built. Each theme includes consistency in styling, layout components, navigation, as well as accessibility adjustments; the UI is stable and ready to integrate independent of modules selected. The theme's addition really took my idea to the next level, I did not expect to be able to do something like this before taking this project on.
    
    Now I want to bring up how different application types can be configured, or modified, as well as the safeguards and innovations added to successfully run the application. The create_app() within app.py is essentially an app factory system which integrates the modular structure that can be used to create multiple app variations with very minimal coding involved in startup (can be enhanced to push beyond the startup stages of development, but for sake of project, the main purpose is to speed up the beginning/introduction stages of application development). An example of the app factory build looks like the following:
	app = create_app(
        modules=['blog', 'chat', 'dashboard', 'database', 'auth'], 
        config={
            'THEME': 'cyberpunk-neon',
            'DASHBOARD_TYPE': 'chat',  
        },
        site_name='Project Title'
    )
    And this is just one example, currently 60+ distinct application types can be created using the 5 modules, 4 themes, and 3 dashboard types (note that main is not counted as its not really as useful, pairable with other modules). When building the app there were a few technical innovations/adaptations made to enhance the developers experience when using the product. A few of which are safe URL builders that prevent broken paths, the smart dependency system which has added console output information, specified configuration-driven dashboards, as well as a consistent template inheritance structure. In concluding the tangible evidence and technical artifacts, I am very happy with the outcome as I feel my initial project planning was implemented in full if not at a higher level than I expected. The tool which can be used to instantly create functional, ready applications was a bit more technical than I had imagined before however it fully encompasses the ideas that I had in my plans. I look forward to adding to and improving this product outside of the course requirements as I feel this is a super useful tool for myself and other developers. 
	
    In this section I would like to give credit where it is due, to the generative AI tools I had used, copilot and chat GPT were integral to my development process. I also want to detail my process of navigating my learning/experience goals. The development process can be broken down into three intensive stages, each influenced by human-AI collaboration.
	
    Stage 1: the design, planning, and architecture. Initial intention in this stage was to create a simple framework for my modular flask development. In my planning I detailed an expandable modular architecture, a separation style structure of templates, static files and routes. I identified specific dependencies between planned modules, and set up clear instructions to create a module loading system. My role in this was defining the vision, adjusting my product requirements, and validating the AI’s work through a number of prompts and reworkings of code/structures written by the AI agent. 
    
    Stage 2: Feature development and numerous iterations of the product. In this phase with the help of the AI tools, I rapidly iterated new features such as new modules, dashboards, themes, as well as enhancements. The AI tools helped me diagnose route errors, repair template inheritance issues, improved accessibility (such as legibility) across themes, implemented database persistence, and really helped expand the added modules (blog and chat). This was a highly interactive collaboration as I tested features, asked questions on what was being added, as well as identifying issues in usability, accessibility, and code; the AI tools were quick to help with solutions, improvements, and code markup/explanations.
	
    Stage 3: Refinement, polishing and overall documentation. The overall focus of this stage was to improve user experience, themes, and add documentation of how to use/modify the application creator. Some of the big takeaways were clarifying how modules interact, standardizing file naming conventions, improving readability, and adding console information related to debugging, modules, themes, title, dashboards and dependencies. In doing so, documentation was added to include integration guides, app creation ideas using existing modules, and an analysis of prompts that successfully implemented my ideas. 
	
    Furthermore, I would like to outline a few ways the AI tools improved my learning, skills and development. One, improving my problem solving skills, AI helped break down complex problems into steps. Problems such as the dependency loops, route conflicts, and handling the database. By breaking problems like these down I was able to work with the AI (through prompts) to gain knowledge not just being given the answer/code solution, but actually explaining the logic, which strengthened my ability to troubleshoot and understand the principles. Two, the vastly accelerated development AI gives me as a developer. If all these tasks had to be done without AI the product would have taken much longer. Third, the AI tools helped me improve my conceptual understanding by giving me deeper insight to high level concepts. These include modular architecture, template inheritance, ORM and database integration, configuration-driven application design, dependency management, and more. Through explanations, code comments, as well as docstrings throughout the coding process I was able to grasp these concepts at a better level of understanding, versus just having the AI write the code. Lastly, I learned to carefully oversee the AI agent to verify the generated code, ensuring there was secure implementation, understanding the reason behind changes the AI made to the code, as well as maintaining an ethics level of authorship responsibility; all of which reinforced responsible and ethical usage of AI.

	In this section I want to share my comparisons of my intentions and my final product, paired with my overall evaluation of the project. My original goal was to create a reusable but simple modular flask system, in order to gauge how useful AI can be in writing such. Compared to my goal, the final results, as I've already said, exceeded my expectations. The smart dependency resolution, the configurable dashboards/themes, as well as the expected module library hold to the task of generating entire web applications in just a couple minutes. As for technical credibility, the framework meets the standard as it functions consistently across modules, no matter which user decides to include in the app. The code follows industry standard security practices, such as password hashing, and a secret key (although not hidden in code yet). The product also demonstrates a maintainable architecture that can be built upon later. The product also includes useful documentation such as usage manuals, configurations, and code artifacts. And even though the product is essentially a demo, the overall behavior supports real production uses. There is a business/student value created as the modules given, paired with the dashboards and themes, translate into an extensive app factory, with 60+ different build combinations resulting in multiple functions available. In connection with course outcomes I’d say the project aligned strongly by demonstrating the following. AI is a learning accelerator and can bridge gaps in knowledge, proving to be an incredibly useful tool, the ethical and informed usage of AI tools, as well as critical thinking through iterative refinement. It follows the standard of using AI for real-world problem solving rather than a shortcut to learning, which helped validate the idea that AI strengthens, not replaces, human understanding.

	In conclusion the product demonstrates how AI can serve as a collaboration tool when working in developing software systems. The framework produced is functional, scalable, and adaptable with good value behind it. The evidence, the process (prompts and collaborating with AI), as well as the final product shares not only a technical achievement but learning growth as well, especially in tune with my goals.
